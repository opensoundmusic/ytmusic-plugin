import puppeteer from 'puppeteer';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const REFRESH_INTERVAL = 86400000;

export async function fetchYouTubeMusicCookies(headless = true) {
    const browser = await puppeteer.launch({
        headless,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    try {
        const page = await browser.newPage();
        
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');

        console.log('Opening YouTube Music...');
        await page.goto('https://music.youtube.com/', { 
            waitUntil: 'networkidle0',
            timeout: 30000 
        });

        await wait(5000);

        const ytcfgData = await page.evaluate(() => {
            if (window.ytcfg && window.ytcfg.data_) {
                return {
                    INNERTUBE_API_KEY: window.ytcfg.data_.INNERTUBE_API_KEY,
                    INNERTUBE_API_VERSION: window.ytcfg.data_.INNERTUBE_API_VERSION,
                    INNERTUBE_CONTEXT: window.ytcfg.data_.INNERTUBE_CONTEXT,
                    INNERTUBE_CLIENT_NAME: window.ytcfg.data_.INNERTUBE_CLIENT_NAME,
                    INNERTUBE_CLIENT_VERSION: window.ytcfg.data_.INNERTUBE_CLIENT_VERSION
                };
            }
            return null;
        });

        if (!ytcfgData || !ytcfgData.INNERTUBE_API_KEY) {
            throw new Error('Failed to extract YouTube Music API configuration');
        }

        console.log('API Key found:', ytcfgData.INNERTUBE_API_KEY.substring(0, 10) + '...');
        console.log('API Version:', ytcfgData.INNERTUBE_API_VERSION);

        await page.evaluate(() => {
            window.scrollTo(0, 500);
        });
        await wait(1000);

        const cookies = await page.cookies();
        
        console.log(`Collected ${cookies.length} cookies`);

        if (cookies.length === 0) {
            throw new Error('No cookies were collected');
        }

        const netscapeCookies = convertToNetscapeFormat(cookies);
        
        const projectRoot = path.join(__dirname, '..');
        const cookiesDir = path.join(projectRoot, 'cookies');
        const cookiePath = path.join(cookiesDir, 'search_cookies.txt');
        const configPath = path.join(cookiesDir, 'ytconfig.json');
        
        if (!fs.existsSync(cookiesDir)) {
            fs.mkdirSync(cookiesDir, { recursive: true });
        }
        
        fs.writeFileSync(cookiePath, netscapeCookies);
        
        const configWithTimestamp = {
            ...ytcfgData,
            fetchedAt: new Date().toISOString(),
            fetchedTimestamp: Date.now()
        };
        
        fs.writeFileSync(configPath, JSON.stringify(configWithTimestamp, null, 2));
        
        console.log('Cookies saved to:', cookiePath);
        console.log('Config saved to:', configPath);
        console.log('Fetched at:', configWithTimestamp.fetchedAt);

        return {
            success: true,
            cookiePath,
            configPath,
            cookies,
            config: configWithTimestamp
        };

    } catch (error) {
        console.error('Error fetching cookies:', error.message);
        return {
            success: false,
            error: error.message
        };
    } finally {
        await browser.close();
    }
}

function convertToNetscapeFormat(cookies) {
    let netscape = '# Netscape HTTP Cookie File\n';
    netscape += '# This file was generated by Puppeteer\n\n';

    cookies.forEach(cookie => {
        const domain = cookie.domain.startsWith('.') ? cookie.domain : '.' + cookie.domain;
        const flag = 'TRUE';
        const path = cookie.path;
        const secure = cookie.secure ? 'TRUE' : 'FALSE';
        const expiration = cookie.expires ? Math.floor(cookie.expires) : 0;
        const name = cookie.name;
        const value = cookie.value;

        netscape += `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}\n`;
    });

    return netscape;
}

export async function initializeCookies() {
    console.log('Checking YouTube Music cookies...');
    
    const projectRoot = path.join(path.dirname(fileURLToPath(import.meta.url)), '..');
    const cookiesDir = path.join(projectRoot, 'cookies');
    const cookiePath = path.join(cookiesDir, 'search_cookies.txt');
    const configPath = path.join(cookiesDir, 'ytconfig.json');
    
    if (fs.existsSync(configPath) && fs.existsSync(cookiePath)) {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        const fetchedTimestamp = config.fetchedTimestamp || 0;
        const timeSinceFetch = Date.now() - fetchedTimestamp;
        const hoursOld = (timeSinceFetch / (1000 * 60 * 60)).toFixed(1);
        
        if (timeSinceFetch < REFRESH_INTERVAL) {
            console.log(`Using existing cookies (${hoursOld} hours old)`);
            console.log(`Next refresh in ${((REFRESH_INTERVAL - timeSinceFetch) / (1000 * 60 * 60)).toFixed(1)} hours`);
            return true;
        } else {
            console.log(`Cookies are ${hoursOld} hours old, refreshing...`);
        }
    } else {
        console.log('No cookies found, fetching new ones...');
    }
    
    const result = await fetchYouTubeMusicCookies(true);
    
    if (result.success) {
        console.log('Cookies initialized successfully!');
        return true;
    } else {
        console.error('Failed to initialize cookies:', result.error);
        return false;
    }
}

if (import.meta.url === `file://${process.argv[1]}`) {
    fetchYouTubeMusicCookies(false)
        .then(result => {
            if (result.success) {
                console.log('Cookies and config fetched successfully!');
                process.exit(0);
            } else {
                console.error('Failed to fetch cookies');
                process.exit(1);
            }
        });
}